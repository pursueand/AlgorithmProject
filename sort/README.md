# 选择排序算法
## 流程 
先把最小的拿出来，
剩下的再把最小的拿出来
剩下的再找最小的
。。。。。。
每次选择还未选择元素中最小的元素
##时间复杂度
O(n^2)

##循环不变量
[0,i)中是已经处理的数据是按从小到大排序好的，[i,n)中是还未处理的数据

##使用泛型来写出通用的排序算法
泛型需要有约束，选择排序是基于可比较的数据间的排序
<E extends Comparable<E>>
传入的数据需要实现Comparable接口

##Comparable 接口
此接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的 compareTo 方法被称为它的自然比较方法。


#插入排序算法
##流程
每次处理一个数据，把这个数据插入到前面已经排好序的数据中

假设前面n-1（n>2）个数据是排好序的，现在要将第n个数据插入到前面排行序的数据中，找到合适的位置插入

就是将第n个和前面的数据做比较，例如按从小到大排序，拿这第n个数依次跟前面的数比较直到有比这个n的数据小的时候就找到了要插入的位置，其他排行序的数据依次往后移动

##时间复杂度
O(n^2)
##循环不变量

跟选择排序一样，
[0,i)是已经排好序的，[i,n)是未排序的

区别是：选择排序[0,i)是已经排好序的，也是最终排完序的位置
      插入排序[0,i)是已经排好序的，但是最终位置可能发生变化

